from time import sleep
from threading import Thread,Event,Lock
from queue import Queue,Empty
import numpy as np
import sounddevice as sd

class VoicePlayer:
    '''
    Module to play audio generated by TTS model

    Args:
        input_q (Queue): Queue to hold audio from TTS. Sample rate must 48000Hz
        playback_device (str): Playback device name. 
        block_size (int): chunk size of audio processing
    '''
    def __init__(self, 
                 input_q:Queue[np.ndarray],
                 playback_device:str="USB Audio Device",
                 block_size:int=500):

        self.input_q = input_q
        self.playback_device = playback_device
        self.block_size=block_size
        self._buf = np.empty(0, np.float32)  # buffer before playing
        self.playing_event = Event() # set if playing
        self._hold_time_q = Queue() # put time to hold playing state
        self.check_thread = Thread(target=self._control_event, daemon=True)
        self._lock = Lock()   
        
    def start(self):
        '''start waiting audio and playing output stream'''
        self.stream = sd.OutputStream(
            samplerate=48000,
            channels=1,
            dtype="float32",
            blocksize=self.block_size,
            device=self.playback_device,
            callback=self._callback,
        )
        self.stream.start()
        self.running = True
        self.check_thread.start()
        

    def _callback(self, outdata, frames, _, status):
        '''get audio and set to output'''
        if status:
            pass
            # print(f"Stream status: {status}", flush=True)
        with self._lock:
            # get audio from queue
            while self._buf.size < frames:
                try:
                    data = self.input_q.get_nowait()
                    if data is None:
                        break
                    chunk = data.astype(np.float32, copy=False)
                    self._buf = np.concatenate((self._buf, chunk))
                except Empty:
                    
                    break

            # output data
            if self._buf.size >= frames:
                outdata[:] = self._buf[:frames, None]
                self._buf = self._buf[frames:]
            else:
                outdata[:] = 0.0


        # add duration time to hold playing event
        if np.any(outdata) and self._buf.size > 0:
            duration = frames / self.stream.samplerate
            self._hold_time_q.put(duration)
        else:
            pass

    def _control_event(self):
        '''hold event for duration time then clear event'''
        while self.running:
            if self._hold_time_q.empty() and self.playing_event.is_set():
                self.playing_event.clear()
                
            elif not self._hold_time_q.empty():
                sleep(self._hold_time_q.get()) # hold playing event during audio
                if not self.playing_event.is_set():
                    self.playing_event.set()
            else:
                sleep(0.01)
            
    def interrupt(self):
        '''stop playing and flush queues'''
        with self._lock:
            self.stream.abort()      # ハードを止める
            self._buf = np.empty(0, np.float32)
            self._flush_queue()      # キューをクリア
            self.playing_event.clear()
            self.stream.start()      # 空で再開（無音）。次の put で鳴る
            
    def _flush_queue(self):
        while not self.input_q.empty():
            try:
                self.input_q.get_nowait()
            except Empty:
                break

     
    def close(self):
        '''stop output stream and close'''
        if self.stream.active:
            self.stream.stop()
        self.stream.close()
        self.running = False
        self.check_thread.join()
